Gallery
=======

tiny code about anything.Deposit them here~

1sortAlgm.cpp：排序的常见算法

2.findANum:编程之美2.8节 寻找符合条件的整数
给定一个正整数N，求一个最小的正整数M(M>1)，使得N*M的十进制表示形式里面只含有1或者0.
直接解法：从2开始枚举M的取值，直至找到符合条件的M。这个方法耗费极大的时间，完全不靠谱。
因为题目是对N*M进行的限定，因此我们可以遍历N*M。将上面的问题转化为：求最小的X，X只含有0或者1，而且X可以被N整除。X/N就是我们要找的M。
这样的话，我们只要遍历X的取值：1，10，11，100，101，110，111......如果我们最后得到的X为k位，时间复杂度为O(2^k)
有没有更好的方法？我们发现以下规律：当计算X=10^k+Y是否可以被N整除时，其时Y能否被N整除已经计算过了，那如果我们使用这个信息，是否可以减少操作。
改进的方法思想：
1.记录Y(k位)除以N的余数，当我们要计算10^k+Y是否可以被N整除时，只需要计算10^k%N+Y%N除以N的余数是否为0即可。（如果仅使用这个思想，那么时间复杂度仍然是O(2^k)）
2.加入Y1和Y2的除以N的余数相同，那么10^k+Y1和10^k+Y2的被N整除的余数也相同。那么，将K位的所有Y分为最多N-1个子空间（可能出现的余数），对于每个字空间可能有多个Y，我们只计算最小的Y即可。其他的余数都相同。

